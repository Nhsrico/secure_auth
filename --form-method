==========================
http://localhost:4000/users/log-out
==========================

# #### Phoenix.Router.NoRouteError at GET /users/log-out

`   no route found for GET /users/log-out (SecureAuthWeb.Router)   `

# ## Available routes

  GET     /                                     SecureAuthWeb.UserLive.Dashboard :index
  GET     /dev/dashboard/css-:md5               Phoenix.LiveDashboard.Assets :css
  GET     /dev/dashboard/js-:md5                Phoenix.LiveDashboard.Assets :js
  GET     /dev/dashboard                        Phoenix.LiveDashboard.PageLive :home
  GET     /dev/dashboard/:page                  Phoenix.LiveDashboard.PageLive :page
  GET     /dev/dashboard/:node/:page            Phoenix.LiveDashboard.PageLive :page
  \*       /dev/mailbox                          Plug.Swoosh.MailboxPreview \[\]
  GET     /users/settings                       SecureAuthWeb.UserLive.Settings :edit
  GET     /users/settings/confirm-email/:token  SecureAuthWeb.UserLive.Settings :confirm\_email
  GET     /users/two-factor-setup               SecureAuthWeb.UserLive.TwoFactorSetup :new
  GET     /dashboard                            SecureAuthWeb.UserLive.Dashboard :index
  POST    /users/update-password                SecureAuthWeb.UserSessionController :update\_password
  GET     /users/register                       SecureAuthWeb.UserLive.Registration :new
  GET     /users/log-in                         SecureAuthWeb.UserLive.Login :new
  GET     /users/log-in/:token                  SecureAuthWeb.UserLive.Confirmation :new
  GET     /users/verify-2fa                     SecureAuthWeb.UserLive.Verify2FA :new
  POST    /users/log-in                         SecureAuthWeb.UserSessionController :create
  DELETE  /users/log-out                        SecureAuthWeb.UserSessionController :delete

\# Phoenix.Router.NoRouteError at GET /users/log-out Exception: \*\* (Phoenix.Router.NoRouteError) no route found for GET /users/log-out (SecureAuthWeb.Router) (secure\_auth 0.1.0) /root/.frameworks/phoenix/phx\_new\_cache/deps/phoenix/lib/phoenix/router.ex:465: SecureAuthWeb.Router.call/2 (secure\_auth 0.1.0) lib/secure\_auth\_web/endpoint.ex:1: SecureAuthWeb.Endpoint.plug\_builder\_call/2 (secure\_auth 0.1.0) /root/.frameworks/phoenix/phx\_new\_cache/deps/plug/lib/plug/debugger.ex:155: SecureAuthWeb.Endpoint."call (overridable 3)"/2 (secure\_auth 0.1.0) lib/secure\_auth\_web/endpoint.ex:1: SecureAuthWeb.Endpoint.call/2 (phoenix 1.8.0-rc.3) lib/phoenix/endpoint/sync\_code\_reload\_plug.ex:22: Phoenix.Endpoint.SyncCodeReloadPlug.do\_call/4 (bandit 1.7.0) lib/bandit/pipeline.ex:131: Bandit.Pipeline.call\_plug!/2 (bandit 1.7.0) lib/bandit/pipeline.ex:42: Bandit.Pipeline.run/5 (bandit 1.7.0) lib/bandit/http1/handler.ex:13: Bandit.HTTP1.Handler.handle\_data/3 (bandit 1.7.0) lib/bandit/delegating\_handler.ex:18: Bandit.DelegatingHandler.handle\_data/3 (bandit 1.7.0) lib/bandit/delegating\_handler.ex:8: Bandit.DelegatingHandler.handle\_continue/2 (stdlib 6.2.2) gen\_server.erl:2335: :gen\_server.try\_handle\_continue/3 (stdlib 6.2.2) gen\_server.erl:2244: :gen\_server.loop/7 (stdlib 6.2.2) proc\_lib.erl:329: :proc\_lib.init\_p\_do\_apply/3 Code: \`/root/.frameworks/phoenix/phx\_new\_cache/deps/phoenix/lib/phoenix/router.ex\` 460 case \_\_match\_route\_\_(decoded, method, host) do 461 {metadata, prepare, pipeline, plug\_opts} -&gt; 462 Phoenix.Router.\_\_call\_\_(conn, metadata, prepare, pipeline, plug\_opts) 463 464 :error -&gt; 465> raise NoRouteError, conn: conn, router: \_\_MODULE\_\_ 466 end 467 end 468 469 defoverridable init: 1, call: 2 470 end \`lib/secure\_auth\_web/endpoint.ex\` 1> defmodule SecureAuthWeb.Endpoint do 2 use Phoenix.Endpoint, otp\_app: :secure\_auth 3 4 # The session will be stored in the cookie and signed, 5 # this means its contents can be read but not tampered with. 6 # Set :encryption\_salt if you would also like to encrypt it. \`/root/.frameworks/phoenix/phx\_new\_cache/deps/plug/lib/plug/debugger.ex\` 150 case conn do 151 %Plug.Conn{path\_info: \[&quot;\_\_plug\_\_&quot;, &quot;debugger&quot;, &quot;action&quot;\], method: &quot;POST&quot;} -&gt; 152 Plug.Debugger.run\_action(conn) 153 154 %Plug.Conn{} -&gt; 155> super(conn, opts) 156 end 157 rescue 158 e in Plug.Conn.WrapperError -&gt; 159 %{conn: conn, kind: kind, reason: reason, stack: stack} = e 160 Plug.Debugger.\_\_catch\_\_(conn, kind, reason, stack, @plug\_debugger) \`lib/secure\_auth\_web/endpoint.ex\` 1> defmodule SecureAuthWeb.Endpoint do 2 use Phoenix.Endpoint, otp\_app: :secure\_auth 3 4 # The session will be stored in the cookie and signed, 5 # this means its contents can be read but not tampered with. 6 # Set :encryption\_salt if you would also like to encrypt it. \`lib/phoenix/endpoint/sync\_code\_reload\_plug.ex\` 17 18 def call(conn, {endpoint, opts}), do: do\_call(conn, endpoint, opts, true) 19 20 defp do\_call(conn, endpoint, opts, retry?) do 21 try do 22> endpoint.call(conn, opts) 23 rescue 24 exception in \[UndefinedFunctionError\] -&gt; 25 case exception do 26 %UndefinedFunctionError{module: ^endpoint} when retry? -&gt; 27 # Sync with the code reloader and retry once \`lib/bandit/pipeline.ex\` 126 end 127 end 128 129 @spec call\_plug!(Plug.Conn.t(), plug\_def()) :: Plug.Conn.t() | no\_return() 130 defp call\_plug!(%Plug.Conn{} = conn, {plug, plug\_opts}) when is\_atom(plug) do 131> case plug.call(conn, plug\_opts) do 132 %Plug.Conn{} = conn -&gt; conn 133 other -&gt; raise(&quot;Expected #{plug}.call/2 to return %Plug.Conn{} but got: #{inspect(other)}&quot;) 134 end 135 end 136 \`lib/bandit/pipeline.ex\` 37 conn = build\_conn!(transport, method, request\_target, headers, conn\_data, opts) 38 span = Bandit.Telemetry.start\_span(:request, measurements, Map.put(metadata, :conn, conn)) 39 40 try do 41 conn 42> |&gt; call\_plug!(plug) 43 |&gt; maybe\_upgrade!() 44 |&gt; case do 45 {:no\_upgrade, conn} -&gt; 46 %Plug.Conn{adapter: {\_mod, adapter}} = conn = commit\_response!(conn) 47 Bandit.Telemetry.stop\_span(span, adapter.metrics, %{conn: conn}) \`lib/bandit/http1/handler.ex\` 8 def handle\_data(data, socket, state) do 9 transport = %Bandit.HTTP1.Socket{socket: socket, buffer: data, opts: state.opts} 10 connection\_span = ThousandIsland.Socket.telemetry\_span(socket) 11 conn\_data = Bandit.SocketHelpers.conn\_data(socket) 12 13> case Bandit.Pipeline.run(transport, state.plug, connection\_span, conn\_data, state.opts) do 14 {:ok, transport} -&gt; maybe\_keepalive(transport, state) 15 {:error, \_reason} -&gt; {:close, state} 16 {:upgrade, \_transport, :websocket, opts} -&gt; do\_websocket\_upgrade(opts, state) 17 end 18 end \`lib/bandit/delegating\_handler.ex\` 13 |&gt; handle\_bandit\_continuation(socket) 14 end 15 16 @impl ThousandIsland.Handler 17 def handle\_data(data, socket, %{handler\_module: handler\_module} = state) do 18> handler\_module.handle\_data(data, socket, state) 19 |&gt; handle\_bandit\_continuation(socket) 20 end 21 22 @impl ThousandIsland.Handler 23 def handle\_shutdown(socket, %{handler\_module: handler\_module} = state) do \`lib/bandit/delegating\_handler.ex\` 3 # Delegates all implementation of the ThousandIsland.Handler behaviour 4 # to an implementation specified in state. Allows for clean separation 5 # between protocol implementations &amp; friction free protocol selection &amp; 6 # upgrades. 7 8> use ThousandIsland.Handler 9 10 @impl ThousandIsland.Handler 11 def handle\_connection(socket, %{handler\_module: handler\_module} = state) do 12 handler\_module.handle\_connection(socket, state) 13 |&gt; handle\_bandit\_continuation(socket) \`gen\_server.erl\` No code available. \`gen\_server.erl\` No code available. \`proc\_lib.erl\` No code available. ## Connection details ### Params %{} ### Request info \* URI: http://localhost:4000/users/log-out \* Query string: ### Headers \* accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,\*/\*;q=0.8,application/signed-exchange;v=b3;q=0.7 \* accept-encoding: gzip, deflate, br, zstd \* connection: keep-alive \* cookie: \_secure\_auth\_key=SFMyNTY.g3QAAAADbQAAAAtfY3NyZl90b2tlbm0AAAAYZ0NRVUlDT05IbFFFSV9rLU5nU2M5UGhxbQAAAA5saXZlX3NvY2tldF9pZG0AAAA7dXNlcnNfc2Vzc2lvbnM6bTVxNjhpbTdLaVVSU3cwT09GWENWQnJkWUJfNXlEWXg5dGM4RmpZV3EtYz1tAAAACnVzZXJfdG9rZW5tAAAAIJuauvIpuyolEUsNDjhVwlQa3WAf-cg2MfbXPBY2Fqvn.vGZW7P1PRqepN\_Z1JvOnBg7kuFATvqAa7w3z7b28hRM \* host: localhost:4000 \* sec-ch-ua: "Not(A:Brand";v="99", "HeadlessChrome";v="133", "Chromium";v="133" \* sec-ch-ua-mobile: ?0 \* sec-ch-ua-platform: "Linux" \* sec-fetch-dest: document \* sec-fetch-mode: navigate \* sec-fetch-site: none \* sec-fetch-user: ?1 \* upgrade-insecure-requests: 1 \* user-agent: Mozilla/5.0 (X11; Linux x86\_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/133.0.6943.16 Safari/537.36 ### Session nil

/root/.frameworks/phoenix/phx\_new\_cache/deps/phoenix/lib/phoenix/router.ex

460        case \_\_match\_route\_\_(decoded, method, host) do
461          {metadata, prepare, pipeline, plug\_opts} ->
462            Phoenix.Router.\_\_call\_\_(conn, metadata, prepare, pipeline, plug\_opts)
463
464          :error ->
465            raise NoRouteError, conn: conn, router: \_\_MODULE\_\_
466        end
467      end
468
469      defoverridable init: 1, call: 2
470    end

SecureAuthWeb.Router.call/2 [Docs](https://hexdocs.pm/secure_auth/0.1.0/SecureAuthWeb.Router.html#call/2) secure\_auth

lib/secure\_auth\_web/endpoint.ex

1defmodule SecureAuthWeb.Endpoint do
2  use Phoenix.Endpoint, otp\_app: :secure\_auth
3
4  # The session will be stored in the cookie and signed,
5  # this means its contents can be read but not tampered with.
6  # Set :encryption\_salt if you would also like to encrypt it.

SecureAuthWeb.Endpoint.plug\_builder\_call/2 secure\_auth

/root/.frameworks/phoenix/phx\_new\_cache/deps/plug/lib/plug/debugger.ex

150          case conn do
151            %Plug.Conn{path\_info: \["\_\_plug\_\_", "debugger", "action"\], method: "POST"} ->
152              Plug.Debugger.run\_action(conn)
153
154            %Plug.Conn{} ->
155              super(conn, opts)
156          end
157        rescue
158          e in Plug.Conn.WrapperError ->
159            %{conn: conn, kind: kind, reason: reason, stack: stack} = e
160            Plug.Debugger.\_\_catch\_\_(conn, kind, reason, stack, @plug\_debugger)

SecureAuthWeb.Endpoint."call (overridable 3)"/2 secure\_auth

lib/secure\_auth\_web/endpoint.ex

1defmodule SecureAuthWeb.Endpoint do
2  use Phoenix.Endpoint, otp\_app: :secure\_auth
3
4  # The session will be stored in the cookie and signed,
5  # this means its contents can be read but not tampered with.
6  # Set :encryption\_salt if you would also like to encrypt it.

SecureAuthWeb.Endpoint.call/2 secure\_auth

lib/phoenix/endpoint/sync\_code\_reload\_plug.ex

17
18  def call(conn, {endpoint, opts}), do: do\_call(conn, endpoint, opts, true)
19
20  defp do\_call(conn, endpoint, opts, retry?) do
21    try do
22      endpoint.call(conn, opts)
23    rescue
24      exception in \[UndefinedFunctionError\] ->
25        case exception do
26          %UndefinedFunctionError{module: ^endpoint} when retry? ->
27            # Sync with the code reloader and retry once

Phoenix.Endpoint.SyncCodeReloadPlug.do\_call/4 phoenix

lib/bandit/pipeline.ex

126    end
127  end
128
129  @spec call\_plug!(Plug.Conn.t(), plug\_def()) :: Plug.Conn.t() | no\_return()
130  defp call\_plug!(%Plug.Conn{} = conn, {plug, plug\_opts}) when is\_atom(plug) do
131    case plug.call(conn, plug\_opts) do
132      %Plug.Conn{} = conn -> conn
133      other -> raise("Expected #{plug}.call/2 to return %Plug.Conn{} but got: #{inspect(other)}")
134    end
135  end
136

Bandit.Pipeline.call\_plug!/2 bandit

lib/bandit/pipeline.ex

37      conn = build\_conn!(transport, method, request\_target, headers, conn\_data, opts)
38      span = Bandit.Telemetry.start\_span(:request, measurements, Map.put(metadata, :conn, conn))
39
40      try do
41        conn
42        |> call\_plug!(plug)
43        |> maybe\_upgrade!()
44        |> case do
45          {:no\_upgrade, conn} ->
46            %Plug.Conn{adapter: {\_mod, adapter}} = conn = commit\_response!(conn)
47            Bandit.Telemetry.stop\_span(span, adapter.metrics, %{conn: conn})

Bandit.Pipeline.run/5 bandit

lib/bandit/http1/handler.ex

8  def handle\_data(data, socket, state) do
9    transport = %Bandit.HTTP1.Socket{socket: socket, buffer: data, opts: state.opts}
10    connection\_span = ThousandIsland.Socket.telemetry\_span(socket)
11    conn\_data = Bandit.SocketHelpers.conn\_data(socket)
12
13    case Bandit.Pipeline.run(transport, state.plug, connection\_span, conn\_data, state.opts) do
14      {:ok, transport} -> maybe\_keepalive(transport, state)
15      {:error, \_reason} -> {:close, state}
16      {:upgrade, \_transport, :websocket, opts} -> do\_websocket\_upgrade(opts, state)
17    end
18  end

Bandit.HTTP1.Handler.handle\_data/3 bandit

lib/bandit/delegating\_handler.ex

13    |> handle\_bandit\_continuation(socket)
14  end
15
16  @impl ThousandIsland.Handler
17  def handle\_data(data, socket, %{handler\_module: handler\_module} = state) do
18    handler\_module.handle\_data(data, socket, state)
19    |> handle\_bandit\_continuation(socket)
20  end
21
22  @impl ThousandIsland.Handler
23  def handle\_shutdown(socket, %{handler\_module: handler\_module} = state) do

Bandit.DelegatingHandler.handle\_data/3 bandit

lib/bandit/delegating\_handler.ex

3  # Delegates all implementation of the ThousandIsland.Handler behaviour
4  # to an implementation specified in state. Allows for clean separation
5  # between protocol implementations & friction free protocol selection &
6  # upgrades.
7
8  use ThousandIsland.Handler
9
10  @impl ThousandIsland.Handler
11  def handle\_connection(socket, %{handler\_module: handler\_module} = state) do
12    handler\_module.handle\_connection(socket, state)
13    |> handle\_bandit\_continuation(socket)

Bandit.DelegatingHandler.handle\_continue/2 bandit

gen\_server.erl

No code available.

:gen\_server.try\_handle\_continue/3 stdlib

gen\_server.erl

No code available.

:gen\_server.loop/7 stdlib

proc\_lib.erl

No code available.

:proc\_lib.init\_p\_do\_apply/3 stdlib

Show only app frames Copy markdown

- secure\_auth /root/.frameworks/phoenix/phx\_new\_cache/deps/phoenix/lib/phoenix/router.ex:465 SecureAuthWeb.Router.call/2
- secure\_auth lib/secure\_auth\_web/endpoint.ex:1 SecureAuthWeb.Endpoint.plug\_builder\_call/2
- secure\_auth /root/.frameworks/phoenix/phx\_new\_cache/deps/plug/lib/plug/debugger.ex:155 SecureAuthWeb.Endpoint."call (overridable 3)"/2
- secure\_auth lib/secure\_auth\_web/endpoint.ex:1 SecureAuthWeb.Endpoint.call/2
- phoenix lib/phoenix/endpoint/sync\_code\_reload\_plug.ex:22 Phoenix.Endpoint.SyncCodeReloadPlug.do\_call/4
- bandit lib/bandit/pipeline.ex:131 Bandit.Pipeline.call\_plug!/2
- bandit lib/bandit/pipeline.ex:42 Bandit.Pipeline.run/5
- bandit lib/bandit/http1/handler.ex:13 Bandit.HTTP1.Handler.handle\_data/3
- bandit lib/bandit/delegating\_handler.ex:18 Bandit.DelegatingHandler.handle\_data/3
- bandit lib/bandit/delegating\_handler.ex:8 Bandit.DelegatingHandler.handle\_continue/2
- stdlib gen\_server.erl:2335 :gen\_server.try\_handle\_continue/3
- stdlib gen\_server.erl:2244 :gen\_server.loop/7
- stdlib proc\_lib.erl:329 :proc\_lib.init\_p\_do\_apply/3

Request info

URI:

http://localhost:4000/users/log-out

Query string:

Headers

accept

text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,\*/\*;q=0.8,application/signed-exchange;v=b3;q=0.7

accept-encoding

gzip, deflate, br, zstd

connection

keep-alive

cookie

\_secure\_auth\_key=SFMyNTY.g3QAAAADbQAAAAtfY3NyZl90b2tlbm0AAAAYZ0NRVUlDT05IbFFFSV9rLU5nU2M5UGhxbQAAAA5saXZlX3NvY2tldF9pZG0AAAA7dXNlcnNfc2Vzc2lvbnM6bTVxNjhpbTdLaVVSU3cwT09GWENWQnJkWUJfNXlEWXg5dGM4RmpZV3EtYz1tAAAACnVzZXJfdG9rZW5tAAAAIJuauvIpuyolEUsNDjhVwlQa3WAf-cg2MfbXPBY2Fqvn.vGZW7P1PRqepN\_Z1JvOnBg7kuFATvqAa7w3z7b28hRM

host

localhost:4000

sec-ch-ua

"Not(A:Brand";v="99", "HeadlessChrome";v="133", "Chromium";v="133"

sec-ch-ua-mobile

?0

sec-ch-ua-platform

"Linux"

sec-fetch-dest

document

sec-fetch-mode

navigate

sec-fetch-site

none

sec-fetch-user

?1

upgrade-insecure-requests

1

user-agent

Mozilla/5.0 (X11; Linux x86\_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/133.0.6943.16 Safari/537.36